"""
Integration tests for Docker deployment and production configuration.

Tests Docker Compose setup, service health, and production readiness.
"""

import pytest
import subprocess
import time
import json
import yaml
from pathlib import Path
from typing import Dict, Any, List
import requests

@pytest.mark.docker
@pytest.mark.integration
class TestDockerDeployment:
    """Test Docker deployment configurations."""
    
    @pytest.fixture(scope="class")
    def project_root(self) -> Path:
        """Get project root directory."""
        return Path(__file__).parent.parent.parent
    
    @pytest.fixture(scope="class")
    def docker_compose_files(self, project_root) -> Dict[str, Path]:
        """Get Docker Compose file paths."""
        return {
            'base': project_root / 'docker compose.yml',
            'override': project_root / 'docker compose.override.yml',
            'prod': project_root / 'docker compose.prod.yml'
        }
    
    def test_docker_compose_file_validity(self, docker_compose_files):
        """Test Docker Compose files are valid YAML."""
        for name, file_path in docker_compose_files.items():
            assert file_path.exists(), f"Docker Compose file missing: {name} ({file_path})"
            
            with open(file_path, 'r') as f:
                try:\n                    compose_config = yaml.safe_load(f)\n                    assert isinstance(compose_config, dict), f\"Invalid YAML structure in {name}\"\n                    assert 'services' in compose_config, f\"No services defined in {name}\"\n                except yaml.YAMLError as e:\n                    pytest.fail(f\"Invalid YAML in {name}: {e}\")\n    \n    def test_docker_compose_service_definitions(self, docker_compose_files):\n        \"\"\"Test required services are defined in Docker Compose.\"\"\"\n        with open(docker_compose_files['base'], 'r') as f:\n            base_config = yaml.safe_load(f)\n        \n        services = base_config.get('services', {})\n        required_services = ['postgres', 'redis', 'backend', 'worker', 'frontend']\n        \n        for service in required_services:\n            assert service in services, f\"Required service '{service}' not found in docker compose.yml\"\n    \n    def test_production_docker_compose_configuration(self, docker_compose_files):\n        \"\"\"Test production Docker Compose configuration.\"\"\"\n        with open(docker_compose_files['prod'], 'r') as f:\n            prod_config = yaml.safe_load(f)\n        \n        services = prod_config.get('services', {})\n        \n        # Check production-specific configurations\n        if 'backend' in services:\n            backend = services['backend']\n            \n            # Should have resource limits in production\n            assert 'deploy' in backend, \"Backend should have deploy configuration in production\"\n            assert 'resources' in backend['deploy'], \"Backend should have resource limits\"\n            \n            # Should use production build target\n            if 'build' in backend:\n                assert backend['build'].get('target') == 'production', \"Backend should use production build target\"\n        \n        # Check that production uses appropriate restart policies\n        for service_name, service_config in services.items():\n            if 'restart' in service_config:\n                assert service_config['restart'] in ['always', 'unless-stopped'], f\"{service_name} should have production restart policy\"\n    \n    def test_environment_variable_configuration(self, docker_compose_files):\n        \"\"\"Test environment variable configuration.\"\"\"\n        with open(docker_compose_files['base'], 'r') as f:\n            base_config = yaml.safe_load(f)\n        \n        services = base_config.get('services', {})\n        \n        # Check backend environment variables\n        if 'backend' in services:\n            backend_env = services['backend'].get('environment', [])\n            \n            # Convert list format to dict if needed\n            if isinstance(backend_env, list):\n                env_dict = {}\n                for env_var in backend_env:\n                    if '=' in env_var:\n                        key, value = env_var.split('=', 1)\n                        env_dict[key] = value\n                backend_env = env_dict\n            \n            required_env_vars = [\n                'DATABASE_URL',\n                'CELERY_BROKER_URL',\n                'CELERY_RESULT_BACKEND'\n            ]\n            \n            for env_var in required_env_vars:\n                assert env_var in backend_env, f\"Required environment variable '{env_var}' not found in backend service\"\n    \n    def test_docker_networks_configuration(self, docker_compose_files):\n        \"\"\"Test Docker networks are properly configured.\"\"\"\n        with open(docker_compose_files['base'], 'r') as f:\n            base_config = yaml.safe_load(f)\n        \n        # Check networks are defined\n        assert 'networks' in base_config, \"No networks defined in docker compose.yml\"\n        \n        networks = base_config['networks']\n        assert 'image2model-network' in networks, \"Main network not defined\"\n        \n        # Check services use the network\n        services = base_config.get('services', {})\n        for service_name, service_config in services.items():\n            if 'networks' in service_config:\n                assert 'image2model-network' in service_config['networks'], f\"{service_name} not connected to main network\"\n    \n    def test_docker_volumes_configuration(self, docker_compose_files):\n        \"\"\"Test Docker volumes are properly configured.\"\"\"\n        with open(docker_compose_files['base'], 'r') as f:\n            base_config = yaml.safe_load(f)\n        \n        # Check volumes are defined\n        assert 'volumes' in base_config, \"No volumes defined in docker compose.yml\"\n        \n        volumes = base_config['volumes']\n        required_volumes = [\n            'postgres_data',\n            'redis_data',\n            'backend_uploads',\n            'backend_results'\n        ]\n        \n        for volume in required_volumes:\n            assert volume in volumes, f\"Required volume '{volume}' not defined\"\n    \n    @pytest.mark.slow\n    def test_docker_compose_build(self, project_root):\n        \"\"\"Test Docker Compose can build all services.\"\"\"\n        cmd = ['docker', 'compose', 'build', '--no-cache']\n        \n        try:\n            result = subprocess.run(\n                cmd,\n                cwd=project_root,\n                capture_output=True,\n                text=True,\n                timeout=600  # 10 minutes timeout for build\n            )\n            \n            if result.returncode != 0:\n                print(f\"Build stdout: {result.stdout}\")\n                print(f\"Build stderr: {result.stderr}\")\n                pytest.fail(f\"Docker Compose build failed with return code {result.returncode}\")\n        \n        except subprocess.TimeoutExpired:\n            pytest.fail(\"Docker Compose build timed out\")\n        except FileNotFoundError:\n            pytest.skip(\"Docker Compose not available\")\n    \n    @pytest.mark.slow\n    def test_production_docker_compose_build(self, project_root):\n        \"\"\"Test production Docker Compose can build.\"\"\"\n        cmd = ['docker', 'compose', '-f', 'docker compose.yml', '-f', 'docker compose.prod.yml', 'build']\n        \n        try:\n            result = subprocess.run(\n                cmd,\n                cwd=project_root,\n                capture_output=True,\n                text=True,\n                timeout=600  # 10 minutes timeout\n            )\n            \n            if result.returncode != 0:\n                print(f\"Production build stdout: {result.stdout}\")\n                print(f\"Production build stderr: {result.stderr}\")\n                pytest.fail(f\"Production Docker Compose build failed with return code {result.returncode}\")\n        \n        except subprocess.TimeoutExpired:\n            pytest.fail(\"Production Docker Compose build timed out\")\n        except FileNotFoundError:\n            pytest.skip(\"Docker Compose not available\")\n    \n    def test_docker_health_checks(self, docker_compose_files):\n        \"\"\"Test Docker health checks are properly configured.\"\"\"\n        with open(docker_compose_files['base'], 'r') as f:\n            base_config = yaml.safe_load(f)\n        \n        services = base_config.get('services', {})\n        \n        # Services that should have health checks\n        health_check_services = ['postgres', 'redis']\n        \n        for service_name in health_check_services:\n            if service_name in services:\n                service_config = services[service_name]\n                assert 'healthcheck' in service_config, f\"{service_name} should have health check configured\"\n                \n                healthcheck = service_config['healthcheck']\n                assert 'test' in healthcheck, f\"{service_name} health check missing test command\"\n                assert 'interval' in healthcheck, f\"{service_name} health check missing interval\"\n                assert 'timeout' in healthcheck, f\"{service_name} health check missing timeout\"\n                assert 'retries' in healthcheck, f\"{service_name} health check missing retries\"\n    \n    def test_docker_compose_override_structure(self, docker_compose_files):\n        \"\"\"Test Docker Compose override file structure.\"\"\"\n        if not docker_compose_files['override'].exists():\n            pytest.skip(\"Docker Compose override file not found\")\n        \n        with open(docker_compose_files['override'], 'r') as f:\n            override_config = yaml.safe_load(f)\n        \n        services = override_config.get('services', {})\n        \n        # Check development-specific overrides\n        if 'backend' in services:\n            backend = services['backend']\n            \n            # Should have development-specific configurations\n            if 'build' in backend:\n                assert backend['build'].get('target') == 'development', \"Override should use development build target\"\n            \n            # Should have volume mounts for development\n            if 'volumes' in backend:\n                volume_mounts = backend['volumes']\n                has_source_mount = any('./backend:/app' in str(mount) for mount in volume_mounts)\n                assert has_source_mount, \"Backend should have source code volume mount in development\"\n    \n    def test_makefile_docker_targets(self, project_root):\n        \"\"\"Test Makefile Docker targets exist.\"\"\"\n        makefile_path = project_root / 'Makefile'\n        \n        if not makefile_path.exists():\n            pytest.skip(\"Makefile not found\")\n        \n        with open(makefile_path, 'r') as f:\n            makefile_content = f.read()\n        \n        # Check for essential Docker targets\n        required_targets = [\n            'up',\n            'down',\n            'build',\n            'logs',\n            'clean'\n        ]\n        \n        for target in required_targets:\n            assert f\"{target}:\" in makefile_content, f\"Makefile target '{target}' not found\"\n    \n    def test_dockerfile_structure(self, project_root):\n        \"\"\"Test Dockerfile structure and best practices.\"\"\"\n        dockerfiles = [\n            project_root / 'backend' / 'Dockerfile',\n            project_root / 'frontend' / 'Dockerfile'\n        ]\n        \n        for dockerfile_path in dockerfiles:\n            if not dockerfile_path.exists():\n                continue\n            \n            with open(dockerfile_path, 'r') as f:\n                dockerfile_content = f.read()\n            \n            # Check for multi-stage build\n            assert 'FROM' in dockerfile_content, f\"No FROM instruction in {dockerfile_path}\"\n            \n            # Check for non-root user (security best practice)\n            has_user_instruction = 'USER' in dockerfile_content\n            has_non_root = any(user in dockerfile_content.lower() for user in ['user app', 'user node', 'user 1000'])\n            \n            # Should have some form of non-root user configuration\n            if has_user_instruction or has_non_root:\n                pass  # Good, has non-root user configuration\n            else:\n                print(f\"Warning: {dockerfile_path} may not have non-root user configuration\")\n    \n    def test_docker_ignore_files(self, project_root):\n        \"\"\"Test .dockerignore files exist and have proper content.\"\"\"\n        dockerignore_files = [\n            project_root / 'backend' / '.dockerignore',\n            project_root / 'frontend' / '.dockerignore'\n        ]\n        \n        for dockerignore_path in dockerignore_files:\n            if not dockerignore_path.exists():\n                continue\n            \n            with open(dockerignore_path, 'r') as f:\n                dockerignore_content = f.read()\n            \n            # Check for common ignore patterns\n            if 'backend' in str(dockerignore_path):\n                common_patterns = ['__pycache__', '*.pyc', '.pytest_cache', 'venv']\n            else:  # frontend\n                common_patterns = ['node_modules', 'dist', '.next']\n            \n            for pattern in common_patterns:\n                if pattern not in dockerignore_content:\n                    print(f\"Warning: {pattern} not found in {dockerignore_path}\")\n    \n    @pytest.mark.slow\n    def test_docker_image_sizes(self, project_root):\n        \"\"\"Test Docker image sizes are reasonable.\"\"\"\n        try:\n            # Build images first\n            build_result = subprocess.run(\n                ['docker', 'compose', 'build'],\n                cwd=project_root,\n                capture_output=True,\n                text=True,\n                timeout=600\n            )\n            \n            if build_result.returncode != 0:\n                pytest.skip(\"Docker build failed, skipping image size test\")\n            \n            # Get image sizes\n            images_result = subprocess.run(\n                ['docker', 'images', '--format', 'table {{.Repository}}\\t{{.Tag}}\\t{{.Size}}'],\n                capture_output=True,\n                text=True\n            )\n            \n            if images_result.returncode == 0:\n                print(\"\\nDocker Image Sizes:\")\n                print(images_result.stdout)\n            \n        except (subprocess.TimeoutExpired, FileNotFoundError):\n            pytest.skip(\"Docker not available or build timed out\")"